<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyBrasil RPG - Vers√£o Final</title>
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/3408/3408506.png" type="image/png">
    <style>
        /* --- ESTILO GERAL --- */
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background-color: #121212; 
            color: #e0e0e0; 
            margin: 0; 
            padding: 20px;
            display: flex;
            justify-content: center;
        }

        /* --- MENU SUPERIOR --- */
        #menu-bar {
            display: flex; gap: 10px; margin-bottom: 15px; justify-content: flex-end;
        }
        .menu-btn {
            background: #333; color: #fff; border: 1px solid #555;
            padding: 8px 15px; border-radius: 4px; cursor: pointer; font-size: 0.9em;
            transition: 0.2s;
        }
        .menu-btn:hover { background: #444; border-color: #bb86fc; color: #bb86fc; }

        /* --- TELA DE LOGIN --- */
        #login-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
        }
        .login-box {
            background: #1e1e1e; padding: 30px; border-radius: 10px; border: 1px solid #444;
            width: 90%; max-width: 400px; text-align: center;
        }
        .login-box input { width: 90%; margin-bottom: 15px; padding: 10px; background: #222; border: 1px solid #555; color: white; }
        .login-btns { display: flex; gap: 10px; justify-content: center; }

        /* --- HUD (Fichas) --- */
        #hud-container {
            position: fixed; top: 20px; right: 20px; width: 240px;
            display: flex; /* Mantido vis√≠vel; a tela de login cobre com z-index */
            flex-direction: column; gap: 15px; z-index: 1000;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .char-card {
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #444; border-left: 4px solid #4caf50;
            padding: 10px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }

        .char-portrait {
            width: 100%; 
            height: 200px; 
            object-fit: contain; /* Mudei de cover para contain para n√£o cortar o personagem */
            object-position: bottom center; /* Alinha o personagem na base */
            background-color: transparent; /* AQUI EST√Å O SEGREDO */
            margin-bottom: 0;
            filter: drop-shadow(0px 5px 5px rgba(236, 64, 122, 0.8)); /* Adiciona sombra no recorte do PNG */
        }

        .char-card h3 { margin: 0 0 2px 0; font-size: 1.1em; color: #fff; }
        .char-info { font-size: 0.8em; color: #aaa; margin-bottom: 5px; }
        .stat-row { display: flex; justify-content: space-between; align-items: center; margin-top: 5px; }
        .hp-bar-bg { width: 60%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; }
        .hp-bar-fill { height: 100%; background: #d32f2f; width: 100%; transition: width 0.5s; }
        .hp-text { font-size: 0.8em; font-weight: bold; }
        .card-back { border-left-color: #2196f3; opacity: 0.85; transform: scale(0.95); transform-origin: right top; }

        /* Cart√£o do Boss (mesmo estilo dos personagens; fica vazio at√© ser usado) */
        .boss-card {
            border-left-color: #bb86fc;
            display: none; /* s√≥ aparece quando houver chefe */
        }
        .boss-card .char-info { color: #c7b3ff; }
        .boss-card .char-portrait { height: 140px; }

        /* --- √ÅREA DO CHAT --- */
        #main-container { width: 100%; max-width: 800px; padding-right: 0; }
        @media (min-width: 1100px) { #main-container { padding-right: 280px; } }

        h1 { text-align: center; color: #bb86fc; margin-bottom: 10px; }
        #chat-box { 
            border: 1px solid #333; height: 65vh; overflow-y: auto; 
            padding: 20px; background: #1e1e1e; margin-bottom: 20px; 
            border-radius: 8px; box-shadow: inset 0 0 15px #000; 
        }

        .user-msg { color: #03dac6; font-weight: bold; margin-top: 20px; text-align: right; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .ai-msg { color: #e0e0e0; margin-bottom: 15px; line-height: 1.6; text-align: left; }
        .typing-cursor::after { content: '‚ñã'; animation: blink 1s infinite; color: #bb86fc; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* --- INPUT --- */
        #input-area { display: flex; gap: 10px; }
        input[type="text"] { flex-grow: 1; padding: 15px; background: #2d2d2d; border: 1px solid #444; color: white; border-radius: 5px; font-size: 16px; outline: none; }
        input:focus { border-color: #bb86fc; }
        button { padding: 15px 30px; background: #bb86fc; color: #000; font-weight: bold; border: none; cursor: pointer; border-radius: 5px; font-size: 16px; transition: 0.3s; }
        button:hover { background: #9965f4; }
        button:disabled { background: #555; cursor: not-allowed; }
        
        .error-msg { color: #ff5555; border: 1px solid #ff5555; padding: 10px; margin-top: 10px; border-radius: 5px; }
        .system-msg { color: #888; font-style: italic; font-size: 0.9em; text-align: center; margin: 10px 0; }

        /* --- VERS√ÉO MOBILE / TABLET (Responsividade) --- */
        @media (max-width: 900px) {
            /* Muda o layout do corpo para coluna (um em cima do outro) */
            body { 
                flex-direction: column; 
                padding: 10px; 
                align-items: center;
            }

            /* O HUD deixa de flutuar na direita e vai para o topo */
            #hud-container {
                position: relative;
                top: auto; right: auto;
                width: 100%;
                flex-direction: row; /* Personagens (e boss) lado a lado */
                flex-wrap: wrap; /* permite quebrar em linhas se necess√°rio */
                margin-bottom: 15px;
                gap: 10px;
            }

            /* Ajusta os cart√µes para dividir o espa√ßo igualmente */
            .char-card {
                flex: 1 1 30%; /* 3 cart√µes podem caber; quebra se precisar */
                font-size: 0.9em; /* Texto um pouco menor */
            }

            /* Imagens menores para economizar tela */
            .char-portrait {
                height: 100px; 
                object-position: top center; /* Foca no rosto */
            }

            /* Remove o espa√ßo que era reservado para o HUD no Desktop */
            #main-container {
                padding-right: 0;
                width: 100%;
            }

            /* Ajusta altura do chat para sobrar espa√ßo para o teclado virtual */
            #chat-box {
                height: 50vh; 
            }

            /* Bot√µes do menu menores e rol√°veis se precisar */
            #menu-bar {
                justify-content: space-between;
                overflow-x: auto;
            }
            
            /* Previne zoom autom√°tico irritante no iPhone ao clicar no input */
            input[type="text"], input[type="password"] {
                font-size: 16px; 
            }
        }
    </style>
</head>
<body>

    <div id="login-screen">
        <div class="login-box">
            <h2 style="color:#bb86fc">HyBrasil RPG</h2>
            <p style="color:#ccc; font-size:0.9em;">Insira sua API Key para come√ßar<br>OU carregue um jogo salvo.</p>
            <input type="password" id="api-key-input" placeholder="Cole sua chave AIza...">
            
            <div class="login-btns">
                <button class="menu-btn" onclick="saveKeyAndStart()">Novo Jogo</button>
                <button class="menu-btn" onclick="document.getElementById('load-file-input').click()">üìÇ Carregar Jogo</button>
            </div>
        </div>
    </div>

    <div id="hud-container">
        <div id="card-1" class="char-card">
            <img id="img-1" src="" class="char-portrait" onerror="this.style.display='none'">
            <h3 id="name-1">P1</h3>
            <div class="char-info" id="class-1">...</div>
            <div class="stat-row">
                <span class="hp-text" id="hp-text-1">PV: ?</span>
                <div class="hp-bar-bg"><div id="hp-bar-1" class="hp-bar-fill"></div></div>
            </div>
            <div class="char-info" style="font-size:0.75em; color:#888; margin-top:5px;">Posi√ß√£o: <span id="pos-1">Frente</span></div>
        </div>

        <div id="card-2" class="char-card card-back">
            <img id="img-2" src="" class="char-portrait" onerror="this.style.display='none'">
            <h3 id="name-2">P2</h3>
            <div class="char-info" id="class-2">...</div>
            <div class="stat-row">
                <span class="hp-text" id="hp-text-2">PV: ?</span>
                <div class="hp-bar-bg"><div id="hp-bar-2" class="hp-bar-fill"></div></div>
            </div>
            <div class="char-info" style="font-size:0.75em; color:#888; margin-top:5px;">Posi√ß√£o: <span id="pos-2">Tr√°s</span></div>
        </div>

        <div id="menu-bar">
                <button class="menu-btn" id="audio-btn" onclick="toggleAudio()">üîá Som: Off</button>
                
                <button class="menu-btn" onclick="confirmNewGame()">üìÑ Novo</button>
                <button class="menu-btn" onclick="saveGame()">üíæ Salvar</button>
                <button class="menu-btn" onclick="document.getElementById('load-file-input').click()">üìÇ Carregar</button>
        </div>
        
        <!-- Cart√£o do Boss (fica vazio/oculto e s√≥ aparece quando houver chefe) -->
        <div id="boss-card" class="char-card boss-card">
            <img id="img-boss" src="" class="char-portrait" onerror="this.style.display='none'">
            <h3 id="boss-name">Chefe</h3>
            <div class="char-info" id="boss-subtitle">...</div>
            <div class="stat-row">
                <span class="hp-text" id="boss-hp-text">PV: ?</span>
                <div class="hp-bar-bg"><div id="boss-hp-bar" class="hp-bar-fill"></div></div>
            </div>
            <div class="char-info" id="boss-desc" style="font-size:0.75em; color:#aaa; margin-top:6px;"></div>
        </div>
    </div>

    <div id="main-container">
            
            <div id="menu-bar">
                <button class="menu-btn" onclick="confirmNewGame()">üìÑ Novo</button>
                <button class="menu-btn" onclick="saveGame()">üíæ Salvar</button>
                <button class="menu-btn" onclick="document.getElementById('load-file-input').click()">üìÇ Carregar</button>
            </div>

            <h1>HyBrasil RPG</h1>
            <div id="chat-box"></div>
            <div id="input-area">
                <input type="text" id="user-input" placeholder="Sua a√ß√£o..." onkeypress="handleEnter(event)" disabled>
                <button id="send-btn" onclick="sendMessage()" disabled>Enviar</button>
            </div>
    </div>

    <input type="file" id="load-file-input" style="display:none" accept=".json" onchange="loadGame(this)">

    <script>
        // --- CONFIGURA√á√ÉO ---
        let API_KEY = ""; 
        const MODEL_NAME = "gemini-2.5-flash"; 
        const RULES_FILENAME = "regras.md"; 

        // Vari√°veis Globais
        let BASE_SYSTEM = ""; 
        let history = []; 
        
        // Elementos DOM
        const chatBox = document.getElementById('chat-box');
        const inputField = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const hudContainer = document.getElementById('hud-container');
        const loginScreen = document.getElementById('login-screen');

        // Cart√£o do Boss
        const bossCard = document.getElementById('boss-card');
        const bossImg = document.getElementById('img-boss');

        // --- CARREGAMENTO AUTOM√ÅTICO DO ARQUIVO .MD ---
        async function loadRules() {
            try {
                const response = await fetch(RULES_FILENAME);
                if (!response.ok) throw new Error(`Arquivo '${RULES_FILENAME}' n√£o encontrado.`);
                BASE_SYSTEM = await response.text();
                console.log("Regras carregadas com sucesso!");
            } catch (error) {
                console.error(error);
                alert(`ERRO CR√çTICO:\nN√£o foi poss√≠vel ler o arquivo '${RULES_FILENAME}'.\nCertifique-se de que o arquivo existe e voc√™ est√° usando um servidor local/GitHub Pages.`);
            }
        }

        loadRules();

        const TECHNICAL_INSTRUCTION = `
        IMPORTANTE - INTEGRA√á√ÉO VISUAL E NARRATIVA:
        No final ABSOLUTO de cada resposta, inclua um bloco JSON atualizado.
        
        REGRAS DE VIL√ïES (BOSS):
        1. Quando houver um chefe (Vil√£o Maior), inclua o campo "enemy_boss" com os dados do chefe (nome, origem, nivel, xp, ataque, vida, habilidade, descricao).
        2. Se um dos 4 Grandes Senhores aparecer pela primeira vez, voc√™ pode tamb√©m preencher "boss_visual" com "NomeEmIngles" (ex: "HiveQueen").
        3. N√ÉO inicie o combate imediatamente. Inicie uma CENA DE DI√ÅLOGO/TENS√ÉO.
        4. O di√°logo/intera√ß√£o pr√©-combate deve durar NO M√ÅXIMO 5 rodadas de conversa.
        5. Se o jogador n√£o atacar antes, no 6¬∫ turno o vil√£o ataca obrigatoriamente.
        
        Use estritamente este formato JSON:
        \`\`\`json_stats
        {
          "p1": { "nome": "Nome", "classe": "Classe", "genero": "M", "hp_atual": 3, "hp_max": 3, "posicao": "Frente" },
          "p2": { "nome": "Nome", "classe": "Classe", "genero": "F", "hp_atual": 4, "hp_max": 4, "posicao": "Tr√°s" },
          "boss_visual": null,
          "enemy_boss": null
        }
        \`\`\`
        (Nota: "boss_visual" deve ser null na maioria das vezes, preencha apenas na rodada de apari√ß√£o).
        `;

        // --- FUN√á√ïES DE CONTROLE ---

        function confirmNewGame() {
            if (confirm("Isso apagar√° o progresso atual. Deseja iniciar uma nova aventura?")) {
                startNewGame();
            }
        }

        function startNewGame() {
            if (!API_KEY) {
                alert("Erro: Nenhuma chave API encontrada. Fa√ßa login novamente.");
                loginScreen.style.display = 'flex';
                return;
            }

            if (!BASE_SYSTEM || BASE_SYSTEM.length < 50) {
                alert("Erro: Regras n√£o carregadas. Verifique 'regras.md'.");
                return;
            }

            const FULL_PROMPT = BASE_SYSTEM + "\n" + TECHNICAL_INSTRUCTION;

            chatBox.innerHTML = '';
            history = [{ role: "user", parts: [{ text: FULL_PROMPT + "\n\nComece perguntando o idioma e a cria√ß√£o da dupla." }] }];
            
            // Reseta visual
            updateCard(1, {nome: "P1", classe: "...", genero: "M", hp_atual: 0, hp_max: 0, posicao: "..."});
            updateCard(2, {nome: "P2", classe: "...", genero: "M", hp_atual: 0, hp_max: 0, posicao: "..."});
            document.getElementById('img-1').style.display = 'none';
            document.getElementById('img-2').style.display = 'none';
            updateBossCard(null);

            addRawMessage("‚öîÔ∏è Iniciando nova aventura...", "system-msg");
            callGemini();
        }

        // Fun√ß√£o auxiliar para esperar (sleep)
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        // --- CONEX√ÉO COM GEMINI ---
        async function callGemini(retryCount = 0) {
            inputField.disabled = true; sendBtn.disabled = true;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${API_KEY}`;

            try {
                const response = await fetch(url, {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: history })
                });

                const data = await response.json();

                // L√ìGICA DE AUTO-RETRY
                if (!response.ok) {
                    if (response.status === 429 || (data.error && data.error.message.includes("quota"))) {
                        if (retryCount < 2) { 
                            let waitTime = 40; 
                            addRawMessage(`‚è≥ Limite do Google atingido. Resfriando motores...`, "system-msg");
                            const countdownDiv = chatBox.lastElementChild;
                            while (waitTime > 0) {
                                countdownDiv.innerText = `‚è≥ Limite do Google atingido. Retomando em ${waitTime}s...`;
                                await sleep(1000); 
                                waitTime--;
                            }
                            countdownDiv.innerText = `üîÑ Retomando conex√£o agora...`;
                            return callGemini(retryCount + 1); 
                        }
                    }
                    throw new Error(data.error?.message || "Erro API");
                }

                let aiText = data.candidates[0].content.parts[0].text;
                
                // 1. Processa JSON (extrai dados e remove do texto)
                const processed = processHUD(aiText); 
                
                // 2. Adiciona texto ao hist√≥rico (limpo, sem JSON)
                history.push({ role: "model", parts: [{ text: processed.cleanText }] });
                
                // 3. Atualiza o cart√£o do Boss (se houver)
                updateBossCard(processed.enemyBoss);
                
                // --- NOVO: MANDA FALAR O TEXTO ---
                speakText(processed.cleanText);
                
                // 4. Efeito de digita√ß√£o
                await typeWriterEffect(processed.cleanText, "ai-msg");

            } catch (error) {
                console.error(error);
                addRawMessage(`‚ùå Erro: ${error.message}`, "error-msg");
                if(error.message.includes("key") || error.message.includes("403")) {
                    alert("Erro de autentica√ß√£o ou Chave inv√°lida.");
                    loginScreen.style.display = 'flex';
                }
            }
            
            inputField.disabled = false; sendBtn.disabled = false; inputField.focus();
        }

        // --- HUD, IMAGENS E PROCESSAMENTO ---
        function processHUD(text) {
            // Aceita 3 formatos:
            // 1) ```json_stats { ... }```
            // 2) ```json { ... }``` (ou qualquer fence de json)
            // 3) Um objeto JSON puro no final da mensagem

            // Captura o √öLTIMO bloco fenced de JSON (modelos √†s vezes geram mais de um bloco)
            const fencedGlobal = /```(?:json_stats|json)\s*([\s\S]*?)```/ig;
            let fencedMatch = null;
            let m;
            while ((m = fencedGlobal.exec(text)) !== null) {
                fencedMatch = m; // mant√©m o √∫ltimo
            }

            // Heur√≠stica: pega o √öLTIMO objeto JSON do texto (para casos sem fence)
            // (Tenta ser conservador para n√£o capturar chaves do meio do texto.)
            const tailJson = /(\{[\s\S]*\})\s*$/;
            const tailMatch = text.match(tailJson);

            let stats = null;
            let jsonSource = null;

            // Helper: tenta extrair apenas o objeto enemy_boss de um texto contendo JSON (mesmo quando o JSON completo n√£o √© parse√°vel)
            function extractEnemyBossObject(rawText) {
                const idx = rawText.search(/"enemy_boss"\s*:\s*\{/i);
                if (idx === -1) return null;

                // Encontra o in√≠cio do objeto (a primeira '{' ap√≥s enemy_boss:)
                const start = rawText.indexOf('{', idx);
                if (start === -1) return null;

                // Faz brace-matching simples para capturar o objeto
                let depth = 0;
                let inStr = false;
                let esc = false;
                for (let i = start; i < rawText.length; i++) {
                    const ch = rawText[i];
                    if (esc) { esc = false; continue; }
                    if (ch === '\\') { esc = true; continue; }
                    if (ch === '"') { inStr = !inStr; continue; }
                    if (inStr) continue;
                    if (ch === '{') depth++;
                    if (ch === '}') {
                        depth--;
                        if (depth === 0) {
                            const objText = rawText.slice(start, i + 1);
                            try { return JSON.parse(objText); } catch (e) { return null; }
                        }
                    }
                }
                return null;
            }

            if (fencedMatch && fencedMatch[1]) {
                jsonSource = fencedMatch[0];
                try { stats = JSON.parse(fencedMatch[1]); } catch (e) { stats = null; }
            }

            if (!stats && tailMatch && tailMatch[1]) {
                // S√≥ tenta parse se parecer plaus√≠vel (evita capturar texto comum)
                const candidate = tailMatch[1].trim();
                if (candidate.startsWith('{') && candidate.endsWith('}')) {
                    try {
                        stats = JSON.parse(candidate);
                        jsonSource = candidate;
                    } catch (e) { stats = null; }
                }
            }

            let bossName = null;
            let bossObj = null;

            if (stats) {
                // Atualiza fichas se existirem
                if (stats.p1) updateCard(1, stats.p1);
                if (stats.p2) updateCard(2, stats.p2);

                // Compatibilidade: formatos antigos e novo formato enemy_boss
                if (stats.boss_visual && stats.boss_visual !== "null") {
                    bossName = stats.boss_visual;
                    // Se vier apenas o nome, cria um objeto m√≠nimo para o cart√£o do chefe.
                    bossObj = { nome: bossName };
                }

                if (stats.enemy_boss) {
                    // Pode vir como objeto ou string
                    if (typeof stats.enemy_boss === 'string') {
                        bossName = stats.enemy_boss;
                        bossObj = { nome: bossName };
                    } else {
                        bossObj = stats.enemy_boss;
                    }
                }

                const cleaned = jsonSource ? text.replace(jsonSource, '').trim() : text.trim();
                return { cleanText: cleaned, enemyBoss: bossObj };
            }

            // Fallback final: se n√£o conseguimos parsear o JSON inteiro, tenta pelo menos extrair enemy_boss
            const bossOnly = extractEnemyBossObject(text);
            if (bossOnly) {
                // N√£o remove nada do texto (para evitar apagar narrativa), apenas ativa o cart√£o.
                return { cleanText: text.trim(), enemyBoss: bossOnly };
            }

            return { cleanText: text, enemyBoss: null };
        }

        // Cart√£o do Boss: exibe/oculta e tenta carregar a imagem do chefe.
        function updateBossCard(enemyBoss) {
            if (!enemyBoss) {
                bossCard.style.display = 'none';
                bossImg.removeAttribute('src');
                bossImg.style.display = 'none';
                document.getElementById('boss-name').innerText = 'Chefe';
                document.getElementById('boss-subtitle').innerText = '...';
                document.getElementById('boss-hp-text').innerText = 'PV: ?';
                document.getElementById('boss-hp-bar').style.width = '0%';
                document.getElementById('boss-desc').innerText = '';
                return;
            }

            bossCard.style.display = 'block';

            const nome = enemyBoss.nome || enemyBoss.name || 'Chefe';
            const origem = enemyBoss.origem || enemyBoss.origin || '';
            const nivel = enemyBoss.nivel ?? enemyBoss.level ?? '';
            const xp = enemyBoss.xp ?? '';
            const ataque = enemyBoss.ataque ?? enemyBoss.attack ?? '';
            const vidaAtual = enemyBoss.vida ?? enemyBoss.life ?? 0;
            const vidaMax = enemyBoss.vida_max ?? enemyBoss.max_life ?? vidaAtual;
            const habilidade = enemyBoss.habilidade || enemyBoss.ability || '';
            const descricao = enemyBoss.descricao || enemyBoss.description || '';

            document.getElementById('boss-name').innerText = nome;
            document.getElementById('boss-subtitle').innerText = `${origem}${origem && nivel !== '' ? ' ‚Ä¢ ' : ''}${nivel !== '' ? 'N√≠vel ' + nivel : ''}${xp !== '' ? ' ‚Ä¢ XP ' + xp : ''}${ataque !== '' ? ' ‚Ä¢ ATQ ' + ataque : ''}${habilidade ? ' ‚Ä¢ ' + habilidade : ''}`.trim();
            document.getElementById('boss-desc').innerText = descricao;

            const safeMax = Math.max(1, Number(vidaMax) || 1);
            const safeCur = Math.max(0, Number(vidaAtual) || 0);
            document.getElementById('boss-hp-text').innerText = `PV: ${safeCur}/${safeMax}`;
            document.getElementById('boss-hp-bar').style.width = `${Math.min(100, (safeCur / safeMax) * 100)}%`;

            // Nome can√¥nico para o arquivo da imagem (BOSS_*.png)
            const raw = String(nome).trim();
            const key = raw.replace(/[^a-z0-9]/gi, '').toLowerCase();
            const canonicalMap = {
                'hivequeen': 'HiveQueen',
                'mightydragon': 'MightyDragon',
                'abyssaloracle': 'AbyssalOracle',
                'lordofdarkness': 'LordOfDarkness'
            };
            const canonical = canonicalMap[key] || raw.replace(/\s+/g, '');
            const filename = `BOSS_${canonical}.png`;

            bossImg.src = filename;
            bossImg.alt = raw;
            bossImg.style.display = 'block';

            bossImg.onerror = function() {
                // Se n√£o existir a imagem, mant√©m o cart√£o vis√≠vel (com texto), mas esconde a imagem.
                this.removeAttribute('src');
                this.style.display = 'none';
                console.log(`Imagem ${filename} n√£o encontrada.`);
            };
        }

        function updateCard(id, data) {
            if (!data) return;
            document.getElementById(`name-${id}`).innerText = data.nome;
            document.getElementById(`class-${id}`).innerText = data.classe;
            document.getElementById(`pos-${id}`).innerText = data.posicao;
            document.getElementById(`hp-text-${id}`).innerText = `PV: ${data.hp_atual}/${data.hp_max}`;
            
            const pct = data.hp_max > 0 ? (data.hp_atual / data.hp_max) * 100 : 0;
            const bar = document.getElementById(`hp-bar-${id}`);
            bar.style.width = `${pct}%`;
            bar.style.background = pct < 30 ? "#ff0000" : "#d32f2f";

            const card = document.getElementById(`card-${id}`);
            const isFront = data.posicao && data.posicao.toLowerCase().includes("frente");
            card.classList.toggle("card-back", !isFront);
            card.style.borderLeftColor = isFront ? "#4caf50" : "#2196f3";

            const imgTag = document.getElementById(`img-${id}`);
            const filename = getImgFilename(data.classe, data.genero);
            if (!imgTag.src.endsWith(filename)) {
                imgTag.style.display = 'block';
                imgTag.src = filename;
            }
        }

        function getImgFilename(c, g) {
            if (!c) return "";
            c = c.toLowerCase();
            let l = 'W';
            if (c.includes('ca√ßa') || c.includes('hunt')) l = 'H';
            else if (c.includes('mag') || c.includes('mage')) l = 'M';
            else if (c.includes('cl√©r') || c.includes('cler')) l = 'C';
            else if (c.includes('pala')) l = 'P';
            return `${l}_${(g && g.toUpperCase() === 'F') ? 'F' : 'M'}.png`;
        }

        // --- SAVE / LOAD ---
        function saveGame() {
            if (!API_KEY) return alert("Inicie um jogo primeiro.");
            const blob = new Blob([JSON.stringify({timestamp: new Date(), apiKey: API_KEY, history: history})], {type: "application/json"});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `HyBrasil_Save.json`;
            a.click();
        }

        function loadGame(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    API_KEY = data.apiKey; history = data.history;
                    loginScreen.style.display = 'none'; hudContainer.style.display = 'flex';
                    chatBox.innerHTML = '';
                    
                    data.history.forEach(msg => {
                        if (msg.role === "model") {
                            const processed = processHUD(msg.parts[0].text);
                            // Se for carregar jogo salvo, n√£o mostra a imagem do boss de novo pra n√£o poluir, 
                            // ou mostra se preferir (basta descomentar abaixo)
                            // if (processed.bossImage) addBossImageToChat(processed.bossImage); 
                            addRawMessage(processed.cleanText, "ai-msg");
                        } else if (msg.role === "user" && !msg.parts[0].text.includes("Aja como")) {
                            addRawMessage(msg.parts[0].text, "user-msg");
                        }
                    });
                    // Garante que o quadro n√£o fique preso em um boss antigo ap√≥s carregar
                    updateBossCard(null);
                    inputField.disabled = false; sendBtn.disabled = false;
                } catch (err) { alert("Erro: " + err.message); }
            };
            reader.readAsText(file); input.value = '';
        }

        // --- UTILIT√ÅRIOS ---
        function checkSavedKey() {
            const savedKey = localStorage.getItem("hybrasil_api_key");
            if (savedKey) { document.getElementById('api-key-input').value = savedKey; API_KEY = savedKey; }
        }
        
        function saveKeyAndStart() {
            const inputKey = document.getElementById('api-key-input').value.trim();
            if (inputKey.length < 10) return alert("Chave inv√°lida!");
            API_KEY = inputKey; localStorage.setItem("hybrasil_api_key", API_KEY);
            loginScreen.style.display = 'none'; hudContainer.style.display = 'flex';
            startNewGame();
        }

        // --- SISTEMA DE √ÅUDIO (TTS) ---
        let isAudioOn = false;
        const synth = window.speechSynthesis;

        function toggleAudio() {
            isAudioOn = !isAudioOn;
            const btn = document.getElementById('audio-btn');
            
            if (isAudioOn) {
                btn.innerText = "üîä Som: On";
                btn.style.borderColor = "#4caf50";
                btn.style.color = "#4caf50";
                // Tenta falar algo curto para "acordar" o sistema de √°udio do navegador
                speakText("√Åudio ativado.");
            } else {
                btn.innerText = "üîá Som: Off";
                btn.style.borderColor = "#555";
                btn.style.color = "#fff";
                synth.cancel(); // Para de falar imediatamente
            }
        }

        function speakText(text) {
            if (!isAudioOn) return;

            // 1. Para qualquer fala anterior para n√£o encavalar
            synth.cancel();

            // 2. Limpa o texto para a narradora n√£o ler formata√ß√£o
            // Remove **, ##, __, ``` e outros s√≠mbolos de Markdown
            let cleanText = text.replace(/[*#_`]/g, ''); 
            // Remove o bloco JSON se por acaso sobrar
            cleanText = cleanText.replace(/\{[\s\S]*\}/g, '');

            // 3. Configura a fala
            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.lang = 'pt-BR'; // For√ßa portugu√™s
            utterance.rate = 1.0; // Velocidade (0.1 a 10)
            utterance.pitch = 1.0; // Tom (0 a 2)

            // Tenta pegar uma voz melhor se dispon√≠vel (ex: Google Portugu√™s)
            const voices = synth.getVoices();
            const ptVoice = voices.find(v => v.lang.includes('pt-BR') && v.name.includes('Google'));
            if (ptVoice) utterance.voice = ptVoice;

            // 4. Fala
            synth.speak(utterance);
        }
        
        async function typeWriterEffect(text, className) {
            const div = document.createElement('div');
            div.className = className + " typing-cursor";
            chatBox.appendChild(div);
            const lines = text.split('\n');
            for (let line of lines) {
                div.innerHTML += line.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>') + "<br>";
                chatBox.scrollTo({ top: chatBox.scrollHeight, behavior: 'smooth' });
                await new Promise(r => setTimeout(r, 10)); 
            }
            div.classList.remove("typing-cursor");
        }

        function addRawMessage(text, className) {
            const div = document.createElement('div');
            div.className = className;
            div.innerHTML = text.replace(/\n/g, '<br>');
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function sendMessage() {
            const text = inputField.value.trim();
            if (!text) return;
            addRawMessage(text, "user-msg");
            history.push({ role: "user", parts: [{ text: text }] });
            inputField.value = '';
            callGemini();
        }
        function handleEnter(e) { if (e.key === 'Enter') sendMessage(); }

        checkSavedKey();
    </script>
</body>

</html>
